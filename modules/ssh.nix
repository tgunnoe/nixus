{ lib, config, ... }:
let
  inherit (lib) types;

  /*
  connections :: ListOf { from.host; from.user; to.host; to.user }

  A list of SSH connections that should be allowed as given by the ssh.access option
  */
  connections = lib.flatten (lib.mapAttrsToList (fromHost: fromHostValue:
    lib.mapAttrsToList (fromUser: fromUserValue:
      lib.mapAttrsToList (toHost: toHostValue:
        lib.mapAttrsToList (toUser: toUserValue:
          lib.optional toUserValue {
            from.host = fromHost;
            from.user = fromUser;
            to.host = toHost;
            to.user = toUser;
          }
        ) toHostValue
      ) fromUserValue.hasAccessTo
    ) fromHostValue.users
  ) config.ssh.access);

  /*
  hostUserPairs :: ListOf { host; user }

  A list of (hosts, user) pairs for every host having a user, as given by ssh.access
  */
  hostUserPairs = lib.unique (lib.concatMap (conn: [ conn.from conn.to ]) connections);

  /*
  hosts :: ListOf Host

  The list of hosts as given by ssh.access
  */
  hosts = map (pair: pair.host) hostUserPairs;

  /*
  hostUsers :: AttrsOf (ListOf User)

  A mapping from host to the list of users it has, as given by ssh.access
  */
  hostUsers = lib.genAttrs hosts (host:
    lib.unique (map (pair: pair.user) (lib.filter (pair: pair.host == host) hostUserPairs))
  );


  userConfig = host: lib.genAttrs hostUsers.${host} (user:
    let
      keys = map
        (conn: config.ssh.access.${conn.from.host}.users.${conn.from.user}.publicKey)
        (lib.filter (conn: conn.to.host == host && conn.to.user == user) connections);
    in {
      openssh.authorizedKeys.keys = lib.mkIf (keys != []) keys;
    });

  knownHostsConfig = host: lib.genAttrs (map (conn: conn.to.host) (lib.filter (conn: conn.from.host == host) connections)) (toHost: {
    hostNames = [ toHost ] ++ config.ssh.access.${toHost}.hostNames ++ lib.optional (host == toHost) "localhost";
    publicKey = config.ssh.access.${toHost}.hostKey or (throw "Host ssh.access.${toHost}.hostKey isn't specified, but we need it to give secure access from ${host}.");
  });


in {

  options.ssh = {

    access = lib.mkOption {
      description = ''
        A specification for which host/user pair should have access to which
        other host/user pair. An entry here essentially makes `ssh user@host`
        work smoothly.

        This works by adding the source users public key to the target users authorized
        keys and by adding the target host key to the source host known hosts.

        Note that hosts are specified with the Nixus node name.
      '';
      example = lib.literalExample ''
        {
          sourceHost = {
            users.sourceUser = {
              # Generate this with ssh-keygen
              publicKey = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDOJYDb9isFfFog88Lzvs1CEfAmcVB7F9NUFzC7XXXXX";
              hasAccessTo = {
                # This allows you to `ssh targetUser@targetHost`
                # from the sourceUser on sourceHost
                targetHost.targetUser = true;
              };
            };
          };

          # The target hosts key needs to be specified
          targetHost = {
            # Usually autogenerated in /etc/ssh/ssh_host_*_key.pub
            hostKey = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIElTpklo4GfIwPG2/HxUzsov9eW7Z0au0hF9HAzXXXXX";
          };
        }
      '';
      type = types.attrsOf (types.submodule ({ name, ... }: let hostName = name; in {

        # TODO: Could there be multiple?
        options.hostKey = lib.mkOption {
          description = ''
            The host key, usually autogenerated in /etc/ssh/ssh_host_*_key.pub

            This needs to be specified if any host/user needs to SSH to this host
          '';
          type = types.str;
        };

        options.hostNames = lib.mkOption {
          description = ''
            The host names this host is reachable from. Among others, this can include
            - local subnet IP addresses
            - public IP addresses
            - VPN IP addresses
            - DNS domains

            Note that the node name itself and localhost (if relevant) are
            implicitly in this list.
          '';
          type = types.listOf types.str;
          default = [];
        };

        options.users = lib.mkOption {
          description = ''
            Which users this host has and the access they should have to which
            hosts.
          '';
          type = types.attrsOf (types.submodule ({ name, ... }: let userName = name; in {
            # TODO: Could there be multiple?
            options.publicKey = lib.mkOption {
              description = ''
                The users public key. This can be generated with `ssh-keygen`
                or `ssh-keygen -t ed25519`. This needs to be specified if this
                user wants to SSH into another host.
              '';
              type = types.str;
            };
            options.hasAccessTo = lib.mkOption {
              description = ''
                Which host/user this hosts user should have access to. A value
                of `<host>.<user> = true` allows `ssh <user>@<host>`.
              '';
              example = lib.literalExample ''
                {
                  targetHost.targetUser = true;
                }
              '';
              type = types.attrsOf (types.attrsOf types.bool);
              default = {};
            };
          }));
          default = {};
        };

      }));
      default = {};
    };

  };

  config = {

    nodes = lib.genAttrs hosts (host: {
      configuration = {
        users.users = userConfig host;
        programs.ssh.knownHosts = knownHostsConfig host;
      };
    });

  };

}
